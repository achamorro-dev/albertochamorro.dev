---
title: 'Patrones GRASP (Parte 1)'
description: En este primer art√≠culo veremos que son los patrones GRASP o patrones de asignaci√≥n de responsabilidad y como nos ayudaran a identificar y asignar responsabilidades en nuestro software. Adem√°s explicaremos 4 de los 9 patrones/principios GRASP  con ejemplos claros en cada uno de ellos.
cover: ../../assets/blog/patrones-grasp-parte-1/patrones-grasp-1-cover.png
alt: Cartel del art√≠culo Patrones GRASP (Parte 1)
tags:
  - software design
date: 2024-06-16
canonicalUrl: https://albertochamorro.dev/blog/patrones-grasp-parte-1
---

import { Image } from 'astro:assets'
import classDiagram from '../../assets/blog/patrones-grasp-parte-1/class-diagram.png'
import classDiagramUseCases from '../../assets/blog/patrones-grasp-parte-1/class-diagram-usecases.png'

## Introducci√≥n

Seguro que si te hablo sobre patrones SOLID al menos alguna vez has o√≠do hablar de ellos y seguramente puedas decirme cuales son. Pero en el mundo del dise√±o de software hay m√°s patrones que nos ayudan a conseguir que nuestro c√≥digo llegue a ser Clean Code.

En este primer cap√≠tulo vamos a ver 4 de los 9 patrones/principios GRASP que nos ayudaran a saber como asignar las responsabilidades en nuestro software con ejemplos claros en cada uno de ellos.

## Empecemos por el principio, ¬øqu√© son los patrones GRASP?

Como sabes, **los patrones** en dise√±o de software **son herramientas o recetas que aproximan una soluci√≥n para resolver problemas comunes** conocidos de una manera eficiente y testada.

GRASP es el acr√≥nimo de General Responsibility Assignment Software Patterns o, traducido al espa√±ol, **patrones de asignaci√≥n de responsabilidad general**. Estos patrones pertenecen a una metodolog√≠a denominada OOAD (Object-Oriented Analysis and Design) que utiliza una orientaci√≥n a objetos para modelar y dise√±ar sistemas.

Los patrones GRASP (aunque muchos son m√°s principios que patrones) nos indican reglas o t√©cnicas para asignar responsabilidades en nuestro software con el fin de mantener bajo acoplamiento, conseguir alta cohesi√≥n y hacer nuestro software m√°s escalable y mantenible.

El listado de los 9 patrones GRASP son:

- Experto de la informaci√≥n (information expert)
- Creador (creator)
- Bajo acoplamiento (low coupling)
- Alta cohesi√≥n (high cohesion)
- Controlador (controller)
- Indirecci√≥n (indirection)
- Polimorfismo (polymorphism)
- Fabricaci√≥n pura (pure fabrication)
- Variaciones protegidas (protected variations)

## Vale pero espera, ¬øa qu√© llamamos responsabilidad?

Muchas veces hablamos sobre responsabilidades pero no siempre queda claro a qu√© nos referimos.

Muy resumido, **la responsabilidad** en dise√±o de software **hace referencia a comportamiento**, es decir **¬´qui√©n¬ª o qu√© tiene la obligaci√≥n de ejecutar** una acci√≥n, **y a conocimiento**, si deber√≠a **saber de o conocer a otros**. Esto implica a todos los niveles, desde un sistema completo, pasando por m√≥dulos, clases, componentes, etc.

Cuando hablamos de ejecutar una acci√≥n no s√≥lo hacemos referencia a ejecutar un algoritmo y ya. Ejecutar una acci√≥n implica desde la creaci√≥n de otros objetos dentro de s√≠ mismo, ejecutar acciones o m√©todos de otros elementos, coordinar actividades entre diferentes objetos, etc.

Ahora que ya sabemos a que nos referimos cuando hablamos de responsabilidad, vamos a ver los 4 primeros patrones definidos por GRASP.

## Experto de la informaci√≥n (information expert)

Problema: ¬øen qu√© debemos basarnos para asignar responsabilidades a un objeto?

El principio **Experto de la informaci√≥n** establece que **una responsabilidad debe asignarse a la clase u objeto que posea la mayor cantidad de informaci√≥n necesaria para cumplir esa responsabilidad**. Con esto conseguiremos aumentar la cohesi√≥n de esa clase u objeto al tener m√°s relaci√≥n entre atributos y comportamiento.

**Patrones y principios relacionados**: bajo acoplamiento, alta cohesi√≥n.

**Smell relacionados:** God class.

## Ejemplo del principio Experto de la informaci√≥n

Imagina que tenemos que calcular el importe total de un pedido. Este pedido (clase `Order`) tiene un listado de items (clase `OrderLine`) d√≥nde cada uno de ellos contiene la informaci√≥n de la cantidad, el precio y el porcentaje de IVA (o impuesto) que debe pagar.

Ahora echemos un vistazo al siguiente c√≥digo, ¬øcrees que respeta el principio de experto de la informaci√≥n?

```tsx {11-17}
class OrderLine {
  productId: Id
  quantity: number
  price: number
  vat: number
}

class Order {
  items: Array<OrderLine>

  getTotal(): number {
    return this.items.reduce((total, item) => {
      const itemTotal = item.quantity * item.price * (1 + item.vat)

      return total + itemTotal
    }, 0)
  }
}
```

Si analizamos el m√©todo `Order.getTotal` vemos que el pedido tiene la responsabilidad de saber c√≥mo se calcula el precio total del pedido al tener la informaci√≥n de los items pero, adem√°s, sabe calcular el importe total de un item concreto cuando toda esa informaci√≥n de precio, cantidad e impuesto se encuentra en la clase `OrderLine`.

En este caso lo correcto ser√≠a calcular el coste total de un item dentro del propio item ya que es donde reside toda la informaci√≥n necesaria para ello, aumentando as√≠ la cohesi√≥n y reutilizaci√≥n de la clase `OrderLine` en caso de que fuera necesario:

```tsx {6-9,15-19}
class OrderLine {
  productId: Id
  quantity: number
  price: number
  vat: number

  getTotal(): number {
    return this.quantity * this.price * (1 + this.vat)
  }
}

class Order {
  items: Array<OrderLine>

  getTotal(): number {
    return this.items.reduce((total, item) => {
      return total + item.getTotal()
    }, 0)
  }
}
```

## Creador (creator)

Problema: ¬øqui√©n o qu√© es el responsable de crear un objeto?

El patr√≥n **Creador** establece **ciertas reglas que tiene que cumplir un objeto B** **para ser responsable de la creaci√≥n de un objeto A**. Estas reglas son:

- Cuando B contiene o utiliza directamente instancias de A
- Cuando B se compone de varias instancias de A
- Cuando B tiene la informaci√≥n para crear A

En ocasiones la creaci√≥n de una nueva instancia es compleja. En estos casos es recomendable delegar la responsabilidad de la creaci√≥n a una clase u objeto auxiliar llamado f√°brica (lo veremos en el patr√≥n de fabricaci√≥n pura en el siguiente cap√≠tulo de patrones GRASP).

**Patrones y principios relacionados:** bajo acoplamiento, Factory pattern.

## Ejemplo del patr√≥n Creador

Siguiendo con el ejemplo anterior del pedido, imagina que ahora necesitamos implementar el a√±adir un nuevo item al pedido. Podemos ver que es el pedido el que contiene instancias de `OrderLine` en su atributo `items` por lo que el responsable de crear un nuevo item deber√≠a ser el pedido, en este caso hemos a√±adido el m√©todo `Order.addItem`.

```tsx {10,17-20}
class OrderLine {
  constructor(private productId: Id, private quantity: number, private price: number, private vat: number) {}

  getTotal(): number {
    return this.quantity * this.price * (1 + this.vat)
  }
}

class Order {
  items: Array<OrderLine>

  getTotal(): number {
    return this.items.reduce((total, item) => {
      return total + item.getTotal()
    }, 0)
  }

  addItem(productId: Id, quantity: number, price: number, vat: number): void {
    const orderLine = new OrderLine(productId, quantity, price, vat)
    this.items.push(orderLine)
  }
}
```

## Bajo acoplamiento (low coupling)

Problema: ¬øc√≥mo mantener un nivel bajo de dependencias, reducir el impacto a un cambio y aumentar la reutilizaci√≥n?

Tal y como dice Craig Larman en su libro ‚ÄúApplying UML and Patterns‚Äù, **el acoplamiento es una medida de la intensidad con la que un elemento est√° conectado a otros, tiene conocimiento de ellos o depende de ellos**.

Un elemento de nuestro software con **alto acoplamiento** a otros elementos externos **puede** **provocar los siguientes problemas**:

- **Un cambio en un elemento** del que dependemos (y al que estamos acoplados) **fuerza que** nosotros **tengamos tambi√©n que cambiar**.
- **Es m√°s dif√≠cil entender** que hace nuestra clase, componente o m√≥dulo de una manera aislada ya que para conocer el funcionamiento completo necesitamos tambi√©n entender los elementos de los que depende.
- **Hace m√°s dif√≠cil su reutilizaci√≥n** porque su uso requiere tambi√©n de los otros elementos de los que depende.

Por lo tanto, las **ventajas de un bajo acoplamiento** ser√≠an:

- **Mayor poder de reutilizaci√≥n**.
- **M√°s f√°cil de entender**.
- **Menos obligaciones de cambiar** por dependencias de terceros.

La fase de an√°lisis y dise√±o es cr√≠tica para mantener un acoplamiento lo m√°s bajo posible. A continuaci√≥n puedes ver algunas acciones que aumentan el acoplamiento:

- A tiene un atributo que hace referencia a B.
- A llama a servicios de B.
- A tiene un m√©todo que hace referencia a una instancia de B.
- A es una subclase directa o indirecta de B.
- B es una interfaz y A la implementa.

Si quieres m√°s detalle de los tipos de acoplamiento que existen te animo a que eches un vistazo a [este art√≠culo de geeksforgeeks](https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/#types-of-coupling).

**Patrones o principios relacionados**: variaciones protegidas, interface segregation principle, dependency injection, composition vs inheritance.

## Alta cohesi√≥n (high cohesion)

Problema: ¬øc√≥mo hacer que la complejidad sea manejable?

¬øQu√© significa cohesi√≥n? **La cohesi√≥n es una medida de lo fuertemente relacionadas y centradas que est√°n las responsabilidades de un elemento**.

Por lo general, un elemento con alta cohesi√≥n suele tener un bajo n√∫mero de m√©todos y variables que est√°n relacionados entre s√≠. Este elemento colabora con otros elementos para distribuir el esfuerzo de una tarea m√°s grande.

Por el contrario, un elemento con baja cohesi√≥n contiene m√©todos y atributos no relacionados o hace demasiado trabajo. Los problemas que conlleva la baja cohesi√≥n son:

- Dif√≠cil entender lo que hace la clase, m√≥dulo o sistema ya que realiza demasiadas cosas.
- Los cambios en una de las responsabilidades de un elemento en particular, puede afectar a las otras responsabilidades.
- Se reduce la reutilizaci√≥n, ya que cualquier consumidor que necesite una de las responsabilidades puede terminar obteniendo funcionalidades no deseadas.

En general, los conceptos de cohesi√≥n y acoplamiento est√°n estrechamente relacionados ya que un alto grado de acoplamiento en un objeto provoca una baja cohesi√≥n del mismo.

Hay m√∫ltiples tipos de cohesi√≥n, puedes echar un vistazo a [este art√≠culo de geeksforgeeks](https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/#types-of-cohesion) para m√°s informaci√≥n.

**Patrones o principios relacionados**: Single Responsibility, bajo acoplamiento, patr√≥n fachada.

**Smells relacionados**: God class, clases ocultas.

## Ejemplo de baja cohesi√≥n y alto acoplamiento

Siguiendo con el contexto de pedidos, imagina estar en un proyecto y encontrarte con una clase de este estilo:

```tsx {15-29}
class OrderService {
  private order: Order
  private orderProcessor: OrderProcessor
  private billGenerator: BillGenerator
  private emailSender: EmailSender
  private orderShiper: OrderShipper

  constructor(order: Order) {
    this.order = order
    this.orderProcessor = new OrderProcessor()
    this.billGenerator = new BillGenerator()
    this.emailSender = new EmailSender()
    this.orderShipper = new OrderShipper()
  }

  public processOrder(): void {
    // L√≥gica para procesar el pedido
  }

  public generateBill(): File {
    // L√≥gica para generar la factura
  }

  public sendConfirmationEmail(): void {
    // L√≥gica para enviar el email de confirmaci√≥n
  }

  public shipOrder(): void {
    // L√≥gica para enviar el pedido
  }
}
```

Si revisamos las responsabilidades de esta clase `OrderService` podemos observar que esta clase puede: procesar el pedido, generar la factura, enviar email de confirmaci√≥n y enviar el pedido al cliente. ¬øHas llegado a ver una clase parecida con tantas responsabilidades? ¬øCrees que es correcto?

Esta clase es considerada una God Class o Large Class, una clase que hace y conoce demasiado. Adem√°s, cualquier cliente que necesite realizar alguna de las operaciones, por ejemplo enviar el email de confirmaci√≥n, veremos que lleva consigo muchas m√°s cosas de las que necesita para realizar esta tarea.

Si esbozamos un diagrama de las relaciones de esta clase podremos ver que cada flecha suma acoplamiento, y eso que s√≥lo mostramos un primer nivel de relaci√≥n:

<Image
  src={classDiagram}
  alt="Diagrama de clases de la clase OrderService con las dependencias de OrderProcessor, BillGenerator, EmailSender y OrderShipper"
/>

Una posible soluci√≥n podr√≠a ser separar cada una de esas responsabilidades (m√©todos) que ten√≠amos detectados en diferentes casos de uso, cada uno de ellos con sus dependencias y par√°metros m√≠nimos necesarios para procesarse:

```tsx {0,8,16,24}
class ProcessOrderUseCase {
  constructor(private orderProcessor: OrderProcessor) {}

  public execute(order: Order): void {
    this.orderProcessor.process(order)
  }
}

class GenerateBillUseCase {
  constructor(private billGenerator: BillGenerator) {}

  public execute(items: Array<OrderItem>): File {
    return this.billGenerator.generate(items)
  }
}

class SendConfirmationEmailUseCase {
  constructor(private emailSender: EmailSender) {}

  public execute(orderId: string, to: string): void {
    this.emailSender.send(to, `Order ${orderId} confirmation`, `Your order ${orderId} has been processed`)
  }
}

class ShipOrderUseCase {
  constructor(private orderShipper: OrderShipper) {}

  public execute(orderId: string, address: Address): void {
    this.orderShipper.ship(orderId, address)
  }
}
```

Si volvemos a esbozar el diagrama veremos que ahora tenemos m√∫ltiples clases especializadas con un bajo acoplamiento. Si recordamos a nuestro cliente que simplemente quer√≠a enviar el email de confirmaci√≥n veremos que ahora tendr√° mucho m√°s acotada la tarea y menos dependencias que cubrir para ejecutarla.

<Image
  src={classDiagramUseCases}
  alt="Diagrama de las clases ProcessOrderUseCase, GenerateBillUseCase, SendConfirmationEmailUseCase y ShipOrderUseCase con sus respectivas dependencias"
/>

## Cierre

En este primer cap√≠tulo hemos visto con ejemplos 4 de los 9 patrones GRASP. S√© que estos conceptos son complejos pero creo que necesarios de conocer y repasar cuando escribimos o leemos nuestro c√≥digo para que este sea m√°s legible, mantenible y escalable.

Te espero en un pr√≥ximo cap√≠tulo para estudiar los 5 patrones restantes (controlador, indirecci√≥n, polimorfismo, fabricaci√≥n pura y variaciones protegidas), ¬°no te los pierdas! üë®‚Äçüíª.

---

Muchas gracias por llegar hasta el final y, si quieres modificar algo de este art√≠culo, puedes hacerlo envi√°ndome una PR editando [este fichero](https://github.com/achamorro-dev/albertochamorro.dev/blob/main/src/content/blog/patrones-grasp-parte-1.mdx).

¬°Hasta la pr√≥xima üëã!
