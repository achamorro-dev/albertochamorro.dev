---
title: 'HOC: Higher Order Components en React con ejemplos'
description: Antes de la revoluci√≥n de los custom hooks, la manera de compartir l√≥gica o comportamientos entre componentes era a trav√©s de los llamados Higher Order Components o HOC para abreviar. En este art√≠culo veremos qu√© son y por qu√© en ocasiones siguen siendo una opci√≥n interesante frente a los custom hook.
cover: ../../assets/blog/hoc-higher-order-components-en-react/higher-order-components-cover-en-react-cover.png
alt: Cartel del art√≠culo Higher Order Components en React
tags:
  - frontend
date: 2024-06-27
canonicalUrl: https://albertochamorro.dev/blog/hoc-higher-order-components-en-react
---

## Introducci√≥n

Con la llegada de los famosos hooks a React en su versi√≥n 16.8, la reutilizaci√≥n de l√≥gica entre componentes se ha vuelto una tarea mucho m√°s sencilla y trivial. Antes de esta revoluci√≥n, la forma que ten√≠amos de compartir l√≥gica o comportamientos entre componentes era a trav√©s de los llamados Higher Order Components o HOC para abreviar.

En este art√≠culo vamos a definir que son los Higher Order Components, c√≥mo crearlos, veremos 4 ejemplos y por qu√© en ocasiones siguen siendo una opci√≥n interesante frente a los custom hook.

## ¬øQu√© son los Higher Order Components?

Un Higher Order Component (o HOC) es un componente que devuelve otro componente. Estos componentes de alto nivel son utilizados para realizar acciones o extender otros componentes con la posibilidad de a√±adir nuevas o modificar sus propiedades.

Este patr√≥n avanzado de creaci√≥n de componentes en React nos permite mantener nuestros componentes m√°s simples y limpios haci√©ndolos ajenos a comportamientos adicionales que no son responsabilidad de esos componentes.

Como he dicho, estos HOC siguen siendo componentes por lo que podemos hacer uso de hooks para manejar estado propio, ejecutar acciones seg√∫n el ciclo de vida del componente, modificar el valor de las propiedades del componente final y m√°s. Son muchos los casos de uso que le podemos dar a este tipo de componentes, vamos a ver como crearlos y alguno de esos casos de uso.

## Creando nuestro primer Higher Order Component

Por convenci√≥n, el nombre de un HOC comienza con la palabra ¬´with¬ª aunque no es algo obligatorio. Veamos un ejemplo muy sencillo:

```tsx
function withPadding(Component) {
  return props => {
    const style = { padding: '0.2rem' }
    return <Component style={style} {...props} />
  }
}
```

Como podemos ver, la funci√≥n `withPadding` recibe un componente como par√°metro de entrada y devuelve una nueva funci√≥n. Esta segunda funci√≥n es el nuevo componente generado que recibe las propiedades del componente original, establece una constante `style` con un padding preestablecido y retorna el componente original pas√°ndole, adem√°s de sus propiedades, una nueva para establecer un padding.

Vamos a ver como podemos usarlo:

```tsx
const Button = () => <button>Click me!</button>

const PaddedButton = withPadding(Button)
```

En este caso tenemos un componente bot√≥n del cual generamos una nueva versi√≥n con el extra de padding que define nuestro HOC.

¬øSencillo verdad?

## Ejemplos de uso de Higher Order Components

El ejemplo anterior ha sido un primer acercamiento a c√≥mo se escriben los HOC. A continuaci√≥n expongo diferentes ejemplos d√≥nde este tipo de componentes destacan por su reutilizaci√≥n.

Los ejemplos est√°n en JavaScript y no en TypeScript para que los ejemplos sean m√°s legibles y no perderte en verbosidad de tipos de TypeScript.

### Haciendo uso de Suspense para mostrar un loader

Por lo general, cuando hacemos fetching de datos deber√≠amos mostrar feedback al usuario de que algo est√° cargando. Esto normalmente se consigue envolviendo nuestro lazy component (o server component si trabajamos con SSR) que realiza el fetching dentro de un componente `Suspense`.

Ahora imagina una aplicaci√≥n de gran tama√±o, puede que tengamos m√∫ltiples componentes que realizan fetching de datos ¬øverdad? ¬øY si creamos un HOC que envuelva otro componente dentro de un componente `Suspense`?

```tsx
// with-suspense.jsx
import { Suspense } from 'react'

export const withSuspense = WrappedComponent => {
  return props => {
    ;<Suspense fallback={<LoadingSkeleton />}>
      <WrappedComponent {...props} />
    </Suspense>
  }
}

// albums.jsx
const Albums = ({ artistId }) => {
  const albums = use(fetchData(`/${artistId}/albums`))
  return (
    <ul>
      {albums.map(album => (
        <li key={album.id}>
          {album.title} ({album.year})
        </li>
      ))}
    </ul>
  )
}

export const SuspendedAlbums = withSuspense(Albums)

// artist-page.jsx
export const ArtistPage = ({ artist }) => {
  return (
    <>
      <h1>{artist.name}</h1>
      <SuspendedAlbums artistId={artist.id} />
    </>
  )
}
```

### Renderizar componente cuando el usuario tiene el rol permitido

En aplicaciones de tipo backoffice o paneles de administraci√≥n por ejemplo, es muy com√∫n que tengamos diferentes tipos de usuarios con diferentes roles. En estos casos puede que tengamos que ocultar informaci√≥n si el usuario no tiene un rol espec√≠fico.

En este ejemplo vamos a crear un HOC donde mostramos el componente final si el usuario logado cumple los roles indicados.

```tsx
// with-authorization.jsx
export const withAuthorization = (WrappedComponent, allowedRoles) => {
  return (props) => {
    const { user } = useLoggedUser()

    if (allowedRoles.includes(user.role)) {
      return <WrappedComponent {...props} />
    }

    return <div>No tienes permiso para ver este contenido.</div>
  }
}

// reports-page.jsx
const ProtectedReports = withAuthorization(ReportsComponent, ['admin', 'data-analyst']);

export const ReportsPage = () => {
	return (
		<h1>Informes</h1>
		<ProtectedReports />
	)
}
```

### Enmascarar informaci√≥n delicada como un n√∫mero de tarjeta

Imagina que est√°s trabajando en una aplicaci√≥n con informaci√≥n sensible como una aplicaci√≥n bancaria y, por lo que sea, llega informaci√≥n sensible en crudo que habr√≠a que mostrar de forma enmascarada.

Obviamente esto no se deber√≠a hacer desde la capa de presentaci√≥n pero si no tenemos otra opci√≥n podemos crear un HOC al que le digamos el componente y los nombres de las propiedades con informaci√≥n sensible para enmascararlas.

```tsx
// with-masked-info.jsx
import { useMemo } from "react"

export const withMaskedInfo = (WrappedComponent, sensitiveKeys) => {
  return (props) => {
    const maskedProps = useMemo(() => {
      const maskedData = Object.values(props).reduce((acc, value, key) => {
        acc[key] = value

        const isSensitiveKey = sensitiveKeys.includes(key)
        const isString = typeof value === 'string'

        if (isSensitiveKey && isString) {
          acc[key] = value.replace(/.(?=.{4})/g, "*")
        }

        return acc
      }, {})

      return maskedData
    }, [props])

    return <WrappedComponent {...maskedProps} />
  }
}

// bank-account.jsx
const BankAccount = ({ accountNumber, accountName, accountBalance }) => {
  return (
    <div>
      <p>Account Number: {accountNumber}</p>
      <p>Account Name: {accountName}</p>
      <p>Account Balance: {accountBalance}‚Ç¨</p>
    </div>
  )
}

export const SensitiveBankAccount = withMaskedInfo(BankAccount, ['accountNumber'])

// header.jsx
const Header = () => {
  return (
    <SensitiveBankAccount accountNumber="1234 5678 9000 1234 5678 9010" accountName="John Doe" accountBalance={1000.00} />
  )
}

// Output
Account Number: *************************9010
Account Name: John Doe
Account Balance: 1000.00‚Ç¨
```

En este ejemplo, hemos creado un HOC llamado `withMaskedInfo` recibe un componente y el listado de propiedades sensibles para enmascarar. Haciendo uso de `useMemo` generamos una nueva versi√≥n de las propiedades con los valores enmascarados y usamos esas propiedades para crear el componente final.

### Inyector de dependencias

En desarrollo de software, una de las claves para disminuir el acoplamiento y facilitar la testabilidad de nuestros artefactos es la implementaci√≥n del principio de inversi√≥n de dependencias (tambi√©n conocido como inversi√≥n de control).

Estas dependencias normalmente se ¬´inyectan¬ª por constructor para poder modificarse desde fuera dependiendo del escenario, pero nuestros componentes son funciones sin constructor. Una de las opciones que tenemos para realizar esa inyecci√≥n de dependencias es a trav√©s de propiedades del componente y un Higher Order Component ¬øa que no te lo imaginabas? üòã.

```tsx
// with-use-case.jsx
const withUseCase = (WrappedComponent, useCaseFn, propName) => {
  return props => {
    const injectedProps = {
      ...props,
      [propName]: useCaseFn,
    }

    return <WrappedComponent {...injectedProps} />
  }
}

// tasks.jsx
export const Tasks = props => {
  const { getTasks } = props
  const [tasks, setTasks] = useState([])

  useEffect(() => {
    const fetchTasks = async () => {
      const data = await getTasks()
      setTasks(data)
    }

    fetchTasks()
  }, [getTasks])

  return (
    <div>
      <h1>Task Details</h1>
      {tasks.map(task => (
        <Task task={task} />
      ))}
    </div>
  )
}

// app.jsx
const TasksWithUseCase = withUseCase(Tasks, getTasksUseCase, 'getTasks')

const App = () => {
  return (
    <div>
      <TasksWithUseCase />
    </div>
  )
}
```

En este ejemplo, hemos creado el HOC llamado `withUseCase` que recibe el componente, la funci√≥n que act√∫a como caso de uso y el nombre de la propiedad del componente donde setear esa funci√≥n.

Al separar el componente de sus dependencias (m√©todo `getTasks`) podremos testear el componente `Tasks` de manera aislada (unit test) si lo necesitamos pasando por props el caso de uso mockeado.

He simplificado el ejemplo a modo ilustrativo pero imagina que `withUseCase` deber√≠a tener la l√≥gica para resolver la dependencia, por ejemplo de un contenedor de dependencias, o recibir m√∫ltiples casos de uso, etc.

## Conclusiones

Es cierto que con la introducci√≥n de los custom hooks y la componentizaci√≥n de forma declarativa, el patr√≥n de creaci√≥n basado en Higher Order Components ha pasado a un segundo nivel.

Aun as√≠ creo que siguen siendo una muy buena opci√≥n en cuanto a separaci√≥n de responsabilidades (los custom hooks se utilizan directamente en los componentes aumentando el acoplamiento) y al boilerplate que se genera en nuestro JSX teniendo que, en ocasiones, envolver componentes entre ellos.

---

Muchas gracias por llegar hasta el final y, si quieres modificar algo de este art√≠culo, puedes hacerlo envi√°ndome una PR editando [este fichero](https://github.com/achamorro-dev/albertochamorro.dev/blob/main/src/content/blog/hoc-higher-order-components-en-react.mdx).

¬°Hasta la pr√≥xima üëã!
