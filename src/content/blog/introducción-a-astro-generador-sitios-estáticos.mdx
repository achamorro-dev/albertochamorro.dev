---
title: Introducci√≥n a Astro, nuevo generador de sitios est√°ticos
description: Astro se denomina as√≠ mismo como un generador de sitios est√°ticos moderno con menos JavaScript. Su soporte a diferentes frameworks y su velocidad lo convierte en una opci√≥n muy interesante para implementar el cada vez m√°s extendido Jamstack.
cover: blog/introduccion-astro/introduccion-astro.png
metaImg: https://res.cloudinary.com/dp1r5podd/image/upload/v1628161077/albertochamorro.dev/introduccion-astro/introduccio%CC%81n_Astro_generador_sitios_esta%CC%81ticos_afj7nf.jpg
alt: Cartel del art√≠culo introducci√≥n a Astro, nuevo generador de sitios est√°ticos
tags:
  - frontend
date: 2021-08-09
canonicalUrl: https://albertochamorro.dev/blog/introducci%C3%B3n-a-astro-generador-sitios-est%C3%A1ticos
---

import RepositoryCard from '../../components/repository-card/repository-card.astro'

De los creadores de Snowpack llega Astro üöÄ, el generador de sitios est√°ticos con un incre√≠ble rendimiento y soporte a los frameworks m√°s populares actualmente del mundo front.

Aunque tiene poco tiempo de vida (su primera versi√≥n en GitHub es del d√≠a 11 de Abril de 2021) no ha pasado para nada desapercibido al acelerar por completo el proceso de creaci√≥n de webs est√°ticas.

Vamos a darle un peque√±o repaso üßê

## ¬øQu√© es Astro?

Astro es un generador de webs est√°ticas moderno, o al menos as√≠ se definen ellos. Su eslogan es "Build faster websites with less client-side Javascript" o en espa√±ol "Construye p√°ginas web m√°s r√°pidas con menos JavaScript del lado del cliente".

Y te preguntar√°s ¬øpero de estos hay muchos ya no? Pues s√≠, pero Astro trae nuevas caracter√≠sticas que lo hacen mucho m√°s atractivo. Algunas de sus mejores funcionalidades son:

- **Soporte multiframework** o, como ellos lo llaman, "Bring Your Own Framework (BYOF)". Puedes utilizar React, Svelte, Vue, Solid, Preact, web components o simplemente HTML + JavaScript.
- **Exporta HTML puro** con el m√≠nimo c√≥digo JavaScript posible para funcionar.
- **Componentes a demanda.** Podemos indicar a Astro cuando son visibles los componentes para cargarlos s√≥lo cuando sean necesarios.
- **Enfocado en el SEO.** Sitemap, RSS, paginaci√≥n, colecciones.
- **Soporte a las herramientas m√°s populares.** TypeScript, Scoped CSS, CSS Modules, Sass, TailwindCSS, Markdown, MDX y m√°s

Suena bien ¬øverdad? Pues vamos a probarlo.

## Antes de empezar...

S√≥lo necesitamos un par de cosas:

- Tener [Node.js](https://nodejs.org/en/) a poder ser en su versi√≥n LTS. Yo actualmente estoy utilizando la versi√≥n 14.17.1.
- Si utilizas [VS Code](https://code.visualstudio.com/) instala su [extensi√≥n oficial](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) para el resaltado de sintaxis en sus componentes `.astro`.

## Comenzando un proyecto con Astro

La forma m√°s f√°cil y r√°pida para empezar es ejecutar `npm init astro <nombre_proyecto>`. En mi caso el proyecto se llamar√° astro-pokedex por lo que he ejecutado lo siguiente:

```bash
npm init astro astro-pokedex
```

Con este comando ejecutaremos el paquete "create-astro" que es el asistente para crear nuestro proyecto. El asistente nos dar√° a elegir para crear la estructura de carpetas entre 4 opciones, en mi caso elegir√© la primera opci√≥n "Starter Kit".

```bash
‚ùØ   Starter Kit (Generic)
    Blog
    Documentation
    Portfolio
```

Despu√©s nos preguntar√° qu√© frameworks vamos a utilizar. Yo voy a elegir React y Vue ü§≠ ¬øpor qu√© no?

```bash
? Which frameworks would you like to use? ‚Ä∫
Instructions:
    ‚Üë/‚Üì: Highlight option
    ‚Üê/‚Üí/[space]: Toggle selection
    a: Toggle all
    enter/return: Complete answer
‚óØ   Preact
‚óâ   React
‚óØ   Solid
‚óØ   Svelte
‚óâ   Vue
```

Una vez termina el asistente nos indica los pasos que necesitamos seguir para instalar y arrancar el proyecto:

```bash
Next steps:
  1: npm install (or pnpm install, yarn, etc)
  2: git init && git add -A && git commit -m "Initial commit" (optional step)
  3: npm start (or pnpm, yarn, etc)
```

## Estructura del proyecto

Veamos el contenido de la carpeta que nos ha creado:

- **public** - Assets como fuentes, √≠conos, im√°genes, estilos, fichero robots, manifest, etc.
- **src** - Carpeta d√≥nde estar√° nuestro c√≥digo. Aqu√≠ ir√°n componentes, p√°ginas y layouts.
  - **src/pages** - Cada fichero `.astro` o `.md` Astro lo interpretar√° como una ruta de tu p√°gina.
  - **src/components** - Aqui ir√°n los componentes reutilizables tanto propios de Astro como de otros frameworks.
- **astro.config.mjs** - Fichero de configuraci√≥n de Astro. Puedes ver todas las opciones disponibles abriendo simplemente el fichero, las propiedades comentadas son los valores por defecto.

## Componentes .astro

Un fichero `.astro` representa un componente de Astro. Los componentes de Astro siguen el patr√≥n **Single-File Component (SFC)** como ya hacen por ejemplo Vue y Svelte.

Estos componentes se dividen en dos partes: la primera parte ser√≠a c√≥digo JavaScript (o TypeScript) siguiendo el patr√≥n Frontmatter y la segunda ser√≠a la template.

Un ejemplo de componente `.astro`:

```jsx
---
import VueCounter from './VueCounter.vue';

const title = 'Hello world!'
const {¬†message } = Astro.props
---
<div class="example-1">
  <h1>{ title }</h1>
  <span>{ message¬†}</span>
  <VueCounter />
</div>
```

Como podemos ver, el fichero comienza con c√≥digo JavaScript (o TypeScript) en un bloque entre etiquetas `---`. Este c√≥digo s√≥lo ser√° procesado en el momento de hacer el build del proyecto pero no ser√° renderizado en el cliente. Las variables y m√©todos que se declaren en este bloque de c√≥digo ser√°n visibles desde el template.

Un componente de Astro tambi√©n puede recibir datos por propiedades. En cada componente Astro tendremos un objeto `Astro.props` d√≥nde podremos extraer los valores de estas propiedades.

El segundo bloque que encontramos en un componente Astro ser√≠a la template. Este bloque es simplemente HTML con soporte a [JSX](https://reactjs.org/docs/introducing-jsx.html) como sistema de templates din√°micos. Como se puede ver en el ejemplo anterior, para mostrar el valor de las variables escribimos sus nombres entre `{}`.

### Fetch y top-level await

Otra caracter√≠stica incre√≠ble a mencionar de los componentes de Astro es la carga de datos remotos para generar el contenido. Astro nos trae por defecto soporte a `fetch` para peticiones externas y `top-level await` que nos permite esperar la respuesta de una promesa sin tener que encapsularla en una funci√≥n de un nivel superior.

Esto nos permitir√≠a hacer algo como esto:

```jsx
---
const response = await fetch('http://example.com/movies.json');
const data = await response.json();
---
<div>{JSON.stringify(data)}</div>
```

Si por ejemplo quisi√©ramos utilizar `fetch` fuera de componentes Astro tendr√≠amos que utilizar la librer√≠a [`node-fetch`](https://github.com/node-fetch/node-fetch) incluida ya en el core de Astro.

```js
import fetch from 'node-fetch'
```

## P√°ginas en Astro

Como he comentado en la secci√≥n estructura del proyecto, en la carpeta `src/pages` podemos incluir ficheros `.astro` y `.md` que Astro convertir√° en rutas de nuestra web.

Por lo tanto si yo creara un fichero `src/pages/about.astro` autom√°ticamente podr√≠a ir al navegador y con la url `http://localhost:3000/about` ver√≠amos el contenido de esa p√°gina. Esto tambi√©n incluye directorios por lo que si creo el fichero `src/pages/about/me.astro` se crear√≠a la url `http://localhost:3000/about/me`.

<u>Una p√°gina siempre tiene la responsabilidad de devolver un template HTML completo</u>, es decir, con su etiqueta `<html>...</html>` y por supuesto incluyendo `<head>` y `<body>`. La etiqueta `<!doctype html>` es opcional porque Astro la a√±ade autom√°ticamente üòâ.

Un ejemplo de p√°gina podr√≠a ser:

```jsx
---
// Component Import
import Tour from '../components/Tour.astro';
---
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{title}</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="stylesheet" href="/style/global.css">
  <link rel="stylesheet" href="/style/home.css">
</head>
<body>
  <main>
    <Tour />
  </main>
</body>
</html>
```

## Layouts

Los layouts (o dise√±os en espa√±ol) son un tipo de componente especial que nos ayudar√° a reutilizar el esqueleto y estilo en diferentes p√°ginas del proyecto. Por convenci√≥n, los layouts se crear√≠an en la carpeta `src/layouts`.

A trav√©s de slots y props hace que su reutilizaci√≥n sea muy sencilla.

Un ejemplo de layout para, por ejemplo, a√±adir navegaci√≥n en todas las p√°ginas:

```jsx{}[src/layouts/BaseLayout.astro]
---
const {title} = Astro.props;
---
<html>
  <head>
    <title>Example Layout: {title}</title>
  </head>
  <body>
    <nav>
      <a href="#">Home</a>
      <a href="#">Posts</a>
      <a href="#">Contact</a>
    </nav>
    <slot />
  </body>
</html>
```

Despu√©s podr√≠amos crear una p√°gina que utilice este layout y hacer uso del slot para cargar el contenido.

```jsx{}[src/pages/index.astro]
---
import BaseLayout from '../layouts/BaseLayout.astro'
---
<BaseLayout title="Homepage">
  <h1>Hello, world!</h1>
  <p>This is my page content. It will be nested inside a layout.</p>
</BaseLayout>
```

Adem√°s podemos extender layouts en otros layouts en los que necesitemos por ejemplo m√°s contenido o componer layouts con otros layouts, por ejemplo, separando el `<head>` en un fichero `src/layouts/BaseHead.astro` y utilizando ese layout en `src/layouts/BaseLayout.astro`. Patr√≥n composite en acci√≥n ü§Ø

## Colecciones

Una colecci√≥n es un tipo de p√°gina especial con la que poder crear diferentes URLs con la misma p√°gina. Este tipo de p√°ginas son f√°ciles de reconocer porque el nombre del archivo comienza por `$` como por ejemplo `src/pages/$posts.astro`.

¬øPara qu√© podemos usar colecciones?

- Crear m√∫ltiples p√°ginas de informaci√≥n remota o local (como ficheros markdown por ejemplo)
- Paginaci√≥n

Para crear una colecci√≥n tendremos que:

1. Crear un fichero dentro de `src/pages` que comience con `$` y el nombre de la ruta que agrupar√° la colecci√≥n. Por ejemplo, `src/pages/$posts.astro` crear√° las URLS dinamicas a partir de `/posts/`.

2. El fichero de la colecci√≥n debe definir y exportar una funci√≥n llamada `createCollection`. Esta funci√≥n ser√° la encargada de descargar la informaci√≥n y devolver un objeto con la definici√≥n de las rutas a crear.

M√°s adelante mostrar√© un ejemplo de colecci√≥n pero si quieres saber m√°s acerca de las colecciones puedes ir [aqu√≠](https://docs.astro.build/core-concepts/collections).

## Proyecto de ejemplo

Ahora llega el momento de escribir un poco de c√≥digo. ¬øQu√© vamos a hacer? Utilizando la API de Pok√©mon [Pok√©Api](https://pokeapi.co/) y [Favware GraphQL Pokemon](https://favware.tech/graphql-pokemon) vamos a crear tres p√°ginas:

1. En la ruta inicial o index tendremos un listado con los posibles colores de los Pok√©mon

2. Una vez seleccionemos un color listaremos los Pok√©mon de ese color. La ruta ser√° /colors/\<color_seleccionado\>

3. Y por √∫ltimo la p√°gina con el detalle del Pok√©mon. La ruta de esta p√°gina ser√° /pokemons/\<nombre_pokemon\>

Recordad que para ir desarrollando y viendo el resultado hay que lanzar el siguiente comando:

```bash
npm run start

> astro-pokedex@0.0.1 start
> astro dev

[14:32:34] [snowpack] Hint: run "snowpack init" to create a project config file. Using defaults...
[14:32:35] [snowpack] Ready!
[14:32:35] [snowpack] watching for file changes...
[dev server] Server started in 878ms.
[dev server] Local: http://localhost:3000/
```

### Layout base

Todas las p√°ginas compartir√°n el mismo layout y tendr√° 3 propiedades:

- **title** - T√≠tulo de la p√°gina
- **description** - Descripci√≥n para SEO
- **prevHref** - Ruta que ha abierto la p√°gina para mostrar un bot√≥n de volver a esa p√°gina

El c√≥digo:

```jsx{}[src/layouts/BaseLayout.astro]
---
const {title, description, prevHref} = Astro.props
---

<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>{title}</title>
    <meta name="description" content={description}>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato&family=Poppins:wght@500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style/global.css">
  </head>
  <body>
    <header class="header">
      {prevHref &&
        <a class="back-link" href="{prevHref}">üëà</a>
      }
      <h1>Astro Pokedex</h1>
    </header>
    <main>
      <slot></slot>
    </main>
  </body>
</html>
```

### Listado de colores

Esta va a ser la p√°gina m√°s sencilla de todas.

```jsx{}[src/pages/index.astro]
---
import BaseLayout from '../layouts/BaseLayout.astro'
import CategoryCard from '../components/CategoryCard.jsx'

const response = await fetch('https://pokeapi.co/api/v2/pokemon-color')
const colors = await response.json()
---

<BaseLayout title="Astro Pokedex - Inicio" description="Pokedex creada con Astro.build">
  <div class="grid grid-cols-2">
    {colors.results.map(color =>
      <CategoryCard href={`/colors/${color.name}`} title={color.name} color={color.name} />
    )}
  </div>
</BaseLayout>
```

Utilizo el m√©todo fetch para descargar el listado de Pok√©mons que guardar√© en la variable `colors`.

Dentro de `colors.results` tenemos el array con los colores por lo que uso la funci√≥n `map` dentro de {} para crear un bucle de JSX y, por cada uno de los colores, devolver el componente `CategoryCard`.

Este componente tiene 5 propiedades:

- **href** - URL a la que ir√° cuando se le haga click.
- **title** - Texto que va a mostrar.
- **color** - Fondo de la tarjeta.
- **image** - URL de la im√°gen que va a mostrar si se informa.
- **pill** - Propiedad true o false para indicar que queremos un estilo m√°s reducido en formato p√≠ldora.

El c√≥digo:

```jsx{}[src/components/CategoryCard.jsx]
export default function CategoryCard({
  href,
  title,
  color,
  image,
  pill,
})¬†{
  return (
    <a
      className={`card ${color} ${pill ? 'pill' : ''}`}
      href={href}
    >
      <h2>{ title }</h2>
      {
        image && <img src={image} alt={title} loading="lazy" />
      }
    </a>
  )
}
```

Y este es el resultado:

<a href="https://res.cloudinary.com/dp1r5podd/image/upload/v1628510706/albertochamorro.dev/introduccion-astro/astro-pokedex-listado-colores_xkzkzd.webp">
  <img
    src="https://res.cloudinary.com/dp1r5podd/image/upload/v1628510706/albertochamorro.dev/introduccion-astro/astro-pokedex-listado-colores_xkzkzd.webp"
    alt="Captura de pantalla del listado de colores"
  />
</a>

### Listado de Pok√©mon por color

La p√°gina anterior era una p√°gina con un listado simple. Para el siguiente ejemplo necesitamos crear una p√°gina llamada colecci√≥n que, por cada uno de los colores, cree una ruta y una p√°gina con informaci√≥n diferente.

```jsx{}[src/pages/$colors.astro]
---
import BaseLayout from '../layouts/BaseLayout.astro'
import CategoryCard from '../components/CategoryCard.jsx'

export async function createCollection() {
  const colors = [];
  for (const index of Array(10).keys()) {
    const response = await fetch(`https://pokeapi.co/api/v2/pokemon-color/${index + 1}`)
    const result = await response.json()
    colors.push(result)
  }

  return {
    route: '/colors/:color',
    paths() {
      return colors.map(color => ({params: {color: color.name}}))
    },
    async props({ params}) {
      return {
        color: colors.find(color => color.name === params.color),
      }
    }
  }
}

const { color } = Astro.props
const IMAGE_URL = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/`

const getPokemonImage = function (pokemon) {
  const urlSplitted = pokemon.url.split('/')
  const pokemonId = urlSplitted[urlSplitted.length - 2]

  return `${IMAGE_URL}${pokemonId}.png`
}
---

<BaseLayout title="{`Color ${color.name} - Astro Pokedex`}" description="{`Color ${color.name} - Astro Pokedex`}" prevHref="/">
  <ul class="grid grid-cols-2">
    {color.pokemon_species.map(pokemon =>
      <li>
        <CategoryCard
          title={pokemon.name}
          color={color.name}
          href={`/pokemons/${pokemon.name}`}
          image={getPokemonImage(pokemon)}
        />
      </li>
    )}
  </ul>
</BaseLayout>
```

Al ser una colecci√≥n, la p√°gina debe exportar una funci√≥n `createCollection`¬†que ser√° la que Astro ejecutar√° al procesar la p√°gina. Esta funci√≥n debe devolver un objeto con la definici√≥n de la ruta, los path para esa ruta y las props que se le van a pasar a la p√°gina de esas rutas.

Al principio de la funci√≥n hago 10 llamadas a la API de Pok√©Api, una por cada color que existe y guardamos todos los resultados en el array `colors`.

<blockquote>
  Si revis√°is el c√≥digo podr√©is ver que espero a que termine una petici√≥n para empezar la siguiente. Claramente no es
  una forma √≥ptima pero estas llamadas s√≥lo se har√°n cuando se compile el proyecto una √∫nica vez por lo que no
  penalizar√° al cliente.
</blockquote>

El resultado:

<a href="https://res.cloudinary.com/dp1r5podd/image/upload/v1628510785/albertochamorro.dev/introduccion-astro/astro-pokedex-listado-pokemons_q0zaff.webp">
  <img
    src="https://res.cloudinary.com/dp1r5podd/image/upload/v1628510785/albertochamorro.dev/introduccion-astro/astro-pokedex-listado-pokemons_q0zaff.webp"
    alt="Captura de pantalla del listado de Pok√©mons"
  />
</a>

### Detalle de un Pok√©mon

Por √∫ltimo, la p√°gina m√°s complicada: el detalle de un Pok√©mon. Una vez m√°s ser√° una colecci√≥n pero algo diferente. Por un lado sacamos el listado de los Pok√©mon, generamos un path para cada uno de ellos y, en el momento de definir las props de cada p√°gina, descargamos el detalle del Pok√©mon y se lo env√≠amos a la p√°gina en la variable `pokemon`.

Esta se complic√≥ m√°s de lo esperado debido al l√≠mite de requests que tiene Pok√©Api por lo que tuve que buscar una soluci√≥n para descargar el detalle de todos los Pok√©mon. Dado que algunos nombres no coincid√≠an con la API de Favware, tuve que a√±adir como alternativa en estos casos la descarga del detalle con Pok√©Api. ü§Ø

<blockquote>
  Hubiera estado genial no tener ese l√≠mite de requests y hubiera simplificado bastante las cosas pero me vino bien para
  mostrar un ejemplo algo m√°s complejo üí™
</blockquote>

Primero el c√≥digo:

```jsx{}[src/pages/$pokemons.astro]
---
import BaseLayout from '../layouts/BaseLayout.astro'
import CategoryCard from '../components/CategoryCard.jsx'
import CharacterCard from '../components/CharacterCard.vue'

export async function createCollection() {
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=1200`)
  const jsonResponse = await response.json()
  const allPokemons = jsonResponse.results

  return {
    route: '/pokemons/:name',
    paths() {
      return allPokemons.map(pokemon => ({params: {name: pokemon.name}}))
    },
    async props({ params}) {
      const response = await fetch('https://graphqlpokemon.favware.tech/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          query: `
            {
              pokemon: getPokemonDetailsByName(pokemon: ${params.name.replace(/-/g, '')}) {
                num
                name: species
                abilities { first second hidden }
                stats: baseStats { hp attack defense specialattack specialdefense speed }
                gender { male female }
                height
                weight
                color
              }
            }
          `
        }),
      }).then(res => res.json())

      let pokemon = {}

      if (response.data?.pokemon) {
        pokemon = {...response.data.pokemon}
        pokemon.color = pokemon.color.toLowerCase()
        pokemon.image = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${pokemon.num}.png`
      } else {
        const pokemonREST = await fetch(`https://pokeapi.co/api/v2/pokemon/${params.name}`).then(res => res.json())
        pokemon = {
          name: pokemonREST.name,
          height: pokemonREST.height,
          weight: pokemonREST.weigh,
          image: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${pokemonREST.id}.png`,
          stats: pokemonREST.stats.map(stat => [stat.stat.name, stat.base_stat]),
          abilities: pokemonREST.abilities.map(({ability}) => ability.name),
          color: '',
        }
      }

      return {
        pokemon,
      }
    }
  }
}

const { pokemon } = Astro.props
---
<BaseLayout
  title="{`${pokemon.name} - Astro Pokedex`}"
  description="{`Pok√©mon ${pokemon.name} - Astro Pokedex`}"
  prevHref="{`/colors/${pokemon.color}`}"
>
  <CategoryCard
    class="m-auto"
    pill
    href={`/colors/${pokemon.color}`}
    title={pokemon.color}
    color={pokemon.color}
  />

  <CharacterCard pokemon={pokemon}
  />
</BaseLayout>
```

Y aqu√≠ el resultado:

<a href="https://res.cloudinary.com/dp1r5podd/image/upload/v1628510706/albertochamorro.dev/introduccion-astro/astro-pokedex-detalle-pokemon_lu29mx.webp">
  <img
    src="https://res.cloudinary.com/dp1r5podd/image/upload/v1628510706/albertochamorro.dev/introduccion-astro/astro-pokedex-detalle-pokemon_lu29mx.webp"
    alt="Captura de pantalla del detalle de un Pok√©mon"
  />
</a>

### Compilaci√≥n y despliegue

Para compilar nuestro proyecto y que Astro genere todas las p√°ginas tenemos que lanzar:

```bash
npm run build
> astro-pokedex@0.0.1 build
> astro build

[config] Set "buildOptions.site" to generate correct canonical URLs and sitemap
[14:34:01] [snowpack] Hint: run "snowpack init" to create a project config file. Using defaults...
[14:34:02] [snowpack] Ready!
[build] ! building pages...
[...]
 ‚îú /pokemons/zygarde-10/index.html                           0.00 kB
 ‚îú /pokemons/zygarde-50/index.html                           0.00 kB
 ‚îú /pokemons/zygarde-complete/index.html                     0.00 kB
 ‚îî /pokemons/zygarde/index.html                              0.00 kB
[build] ‚ñ∂ Build Complete!
```

Dentro de la carpeta `dist` podr√©is ver todo lo que nos ha generado Astro.

Se puede desplegar en cualquier hosting que puedas lanzar `npm` o desplegar ficheros est√°ticos. En la [documentaci√≥n](https://docs.astro.build/guides/deploy) de Astro pod√©is ver ejemplos de los servicios m√°s famosos que pod√©is utilizar.

Yo he utilizado [Vercel](https://vercel.com/) por ser el m√°s simple de todos, de hecho s√≥lo tuve que cambiar el directorio de salida que desplegar√° el front:

<a href="https://res.cloudinary.com/dp1r5podd/image/upload/v1628509707/albertochamorro.dev/introduccion-astro/configuracion-vercel_ntfr6d.webp">
  <img
    src="https://res.cloudinary.com/dp1r5podd/image/upload/v1628509707/albertochamorro.dev/introduccion-astro/configuracion-vercel_ntfr6d.webp"
    alt="Configuraci√≥n del proyecto en Vercel"
  />
</a>

## Conclusiones

La verdad que me ha parecido un framework muy potente y muy r√°pido de conseguir resultados en pocas l√≠neas y con cero configuraci√≥n.

Nos hemos dejado muchas cosas fuera como paginaci√≥n, componentes a demanda, RSS, Markdown,... Puede que me anime con una segunda parte üòá

Os dejo por aqu√≠ algunos enlaces de inter√©s y el repositorio del ejemplo:

[Astro.build](https://astro.build/)

[Demo Astro Pokedex](https://astro-pokedex.vercel.app/)

<RepositoryCard
  href="https://github.com/achamorro-dev/astro-pokedex"
  description="Ejemplo de Pokedex utilizando el framework Astro utilizando componentes de diferentes frameworks."
  name="astro-pokedex"
  language="Astro"
/>
